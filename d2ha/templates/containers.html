<!DOCTYPE html>
<html lang="{{ get_current_lang() }}">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>D2HA – Container</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
  <link rel="icon" type="image/png" href="{{ url_for('static', filename='img/favicon.png') }}">
  {% include 'partials/notifications_styles.html' %}
</head>

<body class="theme-{{ get_current_theme() }}" data-safe-mode="{{ '1' if safe_mode_enabled else '0' }}"
  data-performance-mode="{{ '1' if performance_mode_enabled else '0' }}"
  data-debug-mode="{{ '1' if debug_mode_enabled else '0' }}">
  <header>
    <div class="header-shell">
      {% include 'partials/notifications_panel.html' %}
      <nav id="primaryNav" role="navigation">
        <a href="{{ url_for('ui.index') }}" class="tab {{ 'active' if active_page == 'home' else '' }}">Home</a>
        <a href="{{ url_for('ui.containers_view') }}"
          class="tab {{ 'active' if active_page == 'containers' else '' }}">{{
          t("nav.containers") }}</a>
        <a href="{{ url_for('ui.images_view') }}" class="tab {{ 'active' if active_page == 'images' else '' }}">{{
          t("nav.images") }}</a>
        <a href="{{ url_for('ui.volumes_view') }}" class="tab {{ 'active' if active_page == 'volumes' else '' }}">{{
          t("nav.volumes") }}</a>
        <a href="{{ url_for('ui.networks_view') }}" class="tab {{ 'active' if active_page == 'networks' else '' }}">{{
          t("nav.networks") }}</a>
        <a href="{{ url_for('ui.updates') }}" class="tab {{ 'active' if active_page == 'updates' else '' }}">{{
          t("nav.updates") }}</a>
        <a href="{{ url_for('ui.events_view') }}" class="tab {{ 'active' if active_page == 'events' else '' }}">{{
          t("nav.events") }}</a>
        <a href="{{ url_for('ui.autodiscovery_view') }}"
          class="tab {{ 'active' if active_page == 'autodiscovery' else '' }}">{{ t("nav.autodiscovery") }}</a>
        <a href="{{ url_for('auth.logout') }}" class="tab logout-link">{{ t("nav.logout") }}</a>
      </nav>
    </div>
  </header>

  {% include 'partials/flash_messages.html' %}

  <main>
    <section class="section-summary-bar">
      <div>
        <h3>Stato container</h3>
        <div class="meta">{{ summary.running }} container attivi · {{ summary.total_containers }} totali · {{
          summary.images }} immagini installate</div>
      </div>
    </section>

    {% for stack in stacks %}
    <section class="section-card">
      <div class="section-card-header section-toggle" data-stack-toggle>
        <div class="title">
          <button class="section-toggle-btn" type="button" aria-expanded="true" aria-label="Mostra o nascondi sezione">
            <span class="chevron">▾</span>
          </button>
          <span class="stack-name">{{ 'Senza stack' if stack.name == '_no_stack' else stack.name }}</span>
        </div>
        <div class="section-card-actions">
          <div class="section-card-badge">{{ stack.containers|length }} container</div>
        </div>
      </div>
      <div class="section-card-body stack-content">
        <table class="responsive-table">
          <colgroup>
            <col class="col-select">
            <col class="col-name">
            <col class="col-status">
            <col class="col-uptime">
            <col class="col-cpu">
            <col class="col-ram">
            <col class="col-restart">
            <col class="col-networks">
            <col class="col-ports">
            <col class="col-actions">
          </colgroup>
          <thead>
            <tr>
              <th class="select-col" aria-label="Seleziona"></th>
              <th>Nome</th>
              <th>Stato</th>
              <th>Uptime</th>
              <th>CPU</th>
              <th>RAM</th>
              <th>Restart</th>
              <th>Reti</th>
              <th>Porte</th>
              <th>Azioni</th>
            </tr>
          </thead>
          <tbody>
            {% for c in stack.containers %}
            <tr class="row-clickable" data-container-id="{{ c.id }}" data-container-name="{{ c.name }}"
              data-container-status="{{ c.status.lower() }}">
              <td class="select-col" data-label="Seleziona">
                <label class="checkbox">
                  <input type="checkbox" class="container-select" value="{{ c.id }}" data-container-name="{{ c.name }}"
                    aria-label="Seleziona {{ c.name }}">
                  <span class="checkmark"></span>
                </label>
              </td>
              <td data-label="Nome">
                <div><strong>{{ c.name }}</strong></div>
                <div class="meta">{{ c.image }}</div>
                <div class="meta">{{ c.short_id }}</div>
              </td>
              <td data-label="Stato" data-field="status">
                {% set status = c.status.lower() %}
                {% set css = "status-pill " %}
                {% if status == "running" %}
                {% set css = css + "status-running" %}
                {% elif status in ["exited", "stopped"] %}
                {% set css = css + "status-exited" %}
                {% elif status == "paused" %}
                {% set css = css + "status-paused" %}
                {% elif status == "restarting" %}
                {% set css = css + "status-restarting" %}
                {% else %}
                {% set css = css + "status-paused" %}
                {% endif %}
                <span class="{{ css }}">{{ c.status }}</span>
              </td>
              <td data-label="Uptime" data-field="uptime">{{ c.uptime }}</td>
              <td data-label="CPU" data-field="cpu">{{ c.cpu_percent }}%</td>
              <td data-label="RAM" data-field="ram">{{ c.mem_usage }} ({{ c.mem_percent }}%)</td>
              <td data-label="Restart" data-field="restart">{{ c.restarts }}</td>
              <td data-label="Reti" data-field="networks">
                {% if c.networks %}
                <div class="meta">
                  {% for net in c.networks %}
                  <div>{{ net.name }}{% if net.ip %} – {{ net.ip }}{% endif %}</div>
                  {% endfor %}
                </div>
                {% else %}
                <span class="meta">Nessuna rete</span>
                {% endif %}
              </td>
              <td data-label="Porte" data-field="ports">
                {% if c.ports.mode == 'host' %}
                <div class="meta">Modalità host</div>
                {% elif c.ports.bindings %}
                <div class="meta">
                  {% for port in c.ports.bindings %}
                  <div>{{ port }}</div>
                  {% endfor %}
                </div>
                {% else %}
                <span class="meta">Nessuna porta esposta</span>
                {% endif %}
              </td>
              <td class="actions-cell" data-label="Azioni">
                <div class="actions">
                  <button class="btn-primary-glow" type="button" data-open-modal data-container-id="{{ c.id }}"
                    data-container-name="{{ c.name }}">Dettagli</button>
                  <button class="btn-primary-glow" type="button" data-open-modal data-tab="logs"
                    data-container-id="{{ c.id }}" data-container-name="{{ c.name }}">Logs</button>
                </div>
              </td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </section>
    {% endfor %}
  </main>

  <div class="bulk-bar" id="bulk-bar" aria-hidden="true">
    <div class="bulk-summary"><span id="bulk-count">0</span> container selezionati</div>
    <div class="bulk-actions">
      <button class="btn-chip" type="button" data-bulk-action="start">Avvia</button>
      <button class="btn-chip" type="button" data-bulk-action="stop">Ferma</button>
      <button class="btn-chip" type="button" data-bulk-action="pause">Pausa</button>
      <button class="btn-chip" type="button" data-bulk-action="unpause">Riprendi</button>
      <button class="btn-chip" type="button" data-bulk-action="restart">Riavvia</button>
      <button class="btn-chip" type="button" data-bulk-action="delete">Elimina</button>
    </div>
  </div>

  <div class="modal-backdrop" id="container-modal" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="modal-title">Dettagli container</div>
          <div class="small" id="modal-subtitle"></div>
        </div>
        <button class="modal-close" id="modal-close" aria-label="Chiudi">✕</button>
      </div>
      <div class="modal-tabs">
        <button class="modal-tab active" data-tab="info">Info</button>
        <button class="modal-tab" data-tab="logs">Logs</button>
        <button class="modal-tab" data-tab="updates">{{ t("nav.updates") }}</button>
      </div>
      <div class="modal-body">
        <div class="tab-panel active" data-panel="info">
          <!-- Top Row: Metrics -->
          <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); margin-bottom: 20px;">
            <div class="field">
              <h4>Stato</h4>
              <div id="info-status" class="badge">-</div>
            </div>
            <div class="field">
              <h4>Uptime</h4>
              <div id="info-uptime" style="font-weight:700; font-size:1.1rem;">-</div>
            </div>
            <div class="field">
              <h4>Riavvio</h4>
              <div id="info-restart" style="font-weight:700; font-size:1.1rem;">-</div>
            </div>
          </div>

          <!-- Resources Section -->
          <div class="card"
            style="margin-bottom: 20px; padding: 16px; border: 1px solid var(--border); border-radius: 12px; background: rgba(255,255,255,0.02);">
            <div class="card-header" style="margin-bottom: 12px;">
              <h4 style="margin:0; text-transform:uppercase; color:var(--muted); font-size:0.8rem;">Risorse Live</h4>
            </div>
            <div class="stats-row">
              <div class="stat-box">
                <div class="kv"><span>CPU</span><strong id="stat-cpu">-</strong></div>
                <canvas id="chart-cpu"></canvas>
              </div>
              <div class="stat-box">
                <div class="kv"><span>RAM</span><strong id="stat-ram">-</strong></div>
                <canvas id="chart-ram"></canvas>
              </div>
              <div class="stat-box">
                <div class="kv"><span>Network</span><strong id="stat-net">-</strong></div>
                <canvas id="chart-net"></canvas>
              </div>
            </div>
          </div>

          <!-- Configuration & Details Grid -->
          <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 24px;">
            <!-- Left Column: Config -->
            <div style="display:flex; flex-direction:column; gap:16px;">
              <div class="field">
                <h4>Immagine</h4>
                <div id="info-image" style="word-break:break-all;">-</div>
                <div class="muted" id="info-short-id" style="font-family:monospace; font-size:0.8rem;"></div>
              </div>
              <div class="field">
                <h4>Command</h4>
                <div id="info-command" class="muted"
                  style="font-family:monospace; font-size:0.85rem; word-break:break-all;">-</div>
              </div>
              <div class="field">
                <h4>Reti</h4>
                <div id="info-networks" class="muted">-</div>
              </div>
              <div class="field">
                <h4>Porte</h4>
                <div id="info-ports" class="muted">-</div>
              </div>
              <div class="field">
                <h4>Volumi</h4>
                <div id="info-volumes" class="muted">-</div>
              </div>
            </div>

            <!-- Right Column: Env & Labels -->
            <div style="display:flex; flex-direction:column; gap:16px;">
              <div class="field">
                <h4>Environment</h4>
                <div class="scrollable-table">
                  <table class="table-kv" id="info-env"></table>
                </div>
              </div>
              <div class="field">
                <h4>Label</h4>
                <div class="scrollable-table">
                  <table class="table-kv" id="info-labels"></table>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="tab-panel logs-panel" data-panel="logs">
          <div class="controls">
            <label class="muted"><input type="checkbox" id="logs-auto" checked> Auto-refresh</label>
            <label class="muted">Linee
              <select id="logs-tail" class="select">
                <option value="10">10</option>
                <option value="50">50</option>
                <option value="100" selected>100</option>
                <option value="150">150</option>
                <option value="500">500</option>
                <option value="all">Senza limiti</option>
              </select>
            </label>
            <label class="muted">Severità
              <select id="logs-severity" class="select">
                <option value="all" selected>Tutte</option>
                <option value="error">Errori</option>
                <option value="warn">Warning</option>
                <option value="info">Info</option>
                <option value="debug">Debug</option>
                <option value="other">Altro</option>
              </select>
            </label>
            <button class="inline-btn" id="logs-refresh">Aggiorna ora</button>
          </div>
          <pre class="logs-area" id="logs-output">Seleziona un container...</pre>
        </div>

        <div class="tab-panel" data-panel="updates">
          <div class="grid">
            <div class="field">
              <h4>Immagine</h4>
              <div id="updates-image">-</div>
              <a href="#" id="updates-repo" class="small" target="_blank" rel="noreferrer">Repository</a>
            </div>
            <div class="field">
              <h4>Versioni</h4>
              <div class="kv"><span>Installata</span><span id="updates-installed">-</span></div>
              <div class="kv"><span>Remota</span><span id="updates-remote">-</span></div>
            </div>
            <div class="field">
              <h4>Stato</h4>
              <div id="updates-state" class="badge">-</div>
            </div>
          </div>
          <div class="field">
            <h4>Frequenza controllo</h4>
            <div class="input-row">
              <select id="updates-frequency" class="select" style="min-width:140px;">
                <option value="15">15 min</option>
                <option value="30">30 min</option>
                <option value="60" selected>1 ora</option>
                <option value="180">3 ore</option>
                <option value="720">12 ore</option>
                <option value="1440">Ogni giorno</option>
              </select>
              <button class="inline-btn" id="updates-save">Salva</button>
              <button class="inline-btn" id="updates-check">Check now</button>
            </div>
          </div>
          <div id="updates-feedback" class="small"></div>
        </div>
      </div>
    </div>
  </div>
  <div class="toast-container" id="toast-container"></div>
  <div class="debug-overlay" id="debug-overlay" aria-hidden="true">
    <div class="debug-panel">
      <div class="debug-header">
        <div>
          <div class="debug-eyebrow">Debug live</div>
          <div class="debug-title" id="debug-title">Stream azione</div>
        </div>
        <div class="debug-actions">
          <button class="inline-btn" type="button" id="debug-clear">Pulisci</button>
          <button class="inline-btn" type="button" id="debug-close">Chiudi</button>
        </div>
      </div>
      <div class="debug-body">
        <div class="debug-column">
          <div class="debug-subtitle">Comandi</div>
          <div class="debug-list" id="debug-commands"></div>
        </div>
        <div class="debug-column">
          <div class="debug-subtitle">Log live</div>
          <div class="debug-log" id="debug-logs"></div>
        </div>
      </div>
    </div>
  </div>
  {% include 'partials/notifications_script.html' %}
  <script>
    const stackToggles = Array.from(document.querySelectorAll('[data-stack-toggle]'));
    stackToggles.forEach((header) => {
      const btn = header.querySelector('.section-toggle-btn, .stack-toggle-btn');
      const content = header.nextElementSibling;
      const card = header.closest('.section-card');
      const chevron = btn ? btn.querySelector('.chevron') : null;
      if (!btn || !content) return;

      const setExpanded = (expanded) => {
        content.classList.toggle('collapsed', !expanded);
        if (card) card.classList.toggle('collapsed', !expanded);
        btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        if (chevron) chevron.textContent = expanded ? '▾' : '▸';
      };

      setExpanded(true);

      const toggle = () => {
        const isExpanded = btn.getAttribute('aria-expanded') === 'true';
        setExpanded(!isExpanded);
      };

      btn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggle();
      });

      header.addEventListener('click', (event) => {
        if (event.target === btn || btn.contains(event.target)) return;
        toggle();
      });
    });

    const modalEl = document.getElementById('container-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalSubtitle = document.getElementById('modal-subtitle');
    const tabButtons = Array.from(document.querySelectorAll('.modal-tab'));
    const tabPanels = Array.from(document.querySelectorAll('.tab-panel'));
    const logOutput = document.getElementById('logs-output');
    const logAuto = document.getElementById('logs-auto');
    const logTail = document.getElementById('logs-tail');
    const logSeverity = document.getElementById('logs-severity');
    const logRefreshBtn = document.getElementById('logs-refresh');
    const updatesFrequency = document.getElementById('updates-frequency');
    const updatesSave = document.getElementById('updates-save');
    const updatesCheck = document.getElementById('updates-check');
    const updatesFeedback = document.getElementById('updates-feedback');
    const toastContainer = document.getElementById('toast-container');
    const bulkBar = document.getElementById('bulk-bar');
    const bulkCount = document.getElementById('bulk-count');
    const bulkButtons = Array.from(document.querySelectorAll('[data-bulk-action]'));
    const selectionInputs = Array.from(document.querySelectorAll('.container-select'));
    const actionButtons = Array.from(document.querySelectorAll('[data-action-btn]'));
    const debugOverlay = document.getElementById('debug-overlay');
    const debugTitle = document.getElementById('debug-title');
    const debugCommands = document.getElementById('debug-commands');
    const debugLogs = document.getElementById('debug-logs');
    const debugClose = document.getElementById('debug-close');
    const debugClear = document.getElementById('debug-clear');

    const rowIndex = new Map();
    Array.from(document.querySelectorAll('tr[data-container-id]')).forEach((row) => {
      rowIndex.set(row.dataset.containerId, row);
    });

    const actionPendingLabels = {
      start: 'Avvio...',
      stop: 'Arresto...',
      restart: 'Riavvio...',
      pause: 'Pausa...',
      unpause: 'Ripresa...',
      delete: 'Eliminazione...'
    };

    const actionSuccessLabels = {
      start: 'avviato',
      stop: 'fermato',
      restart: 'riavviato',
      pause: 'messo in pausa',
      unpause: 'ripreso',
      delete: 'eliminato'
    };

    let currentContainerId = null;
    let statsInterval = null;
    let logsInterval = null;
    let lastLogs = '';
    let statsHistory = { cpu: [], ram: [], net: [] };
    let lastNet = null;
    const selectedContainers = new Map();
    const pollingDefaults = { statsIntervalMs: 3000, logsIntervalMs: 4000, historyLimit: 40 };
    const pollingPerformance = { statsIntervalMs: 5000, logsIntervalMs: 7000, historyLimit: 20 };
    let statsIntervalMs = pollingDefaults.statsIntervalMs;
    let logsIntervalMs = pollingDefaults.logsIntervalMs;
    let statsSampleLimit = pollingDefaults.historyLimit;
    let activeTab = 'info';
    const debugEnabled = document.body.dataset.debugMode === '1';
    const debugStreamSupported = debugEnabled && typeof EventSource !== 'undefined';
    let activeDebugStream = null;

    const safeParseEvent = (evt) => {
      try { return JSON.parse(evt.data); }
      catch (e) { return {}; }
    };

    const clearDebugOverlay = () => {
      if (!debugOverlay) return;
      debugCommands.innerHTML = '';
      debugLogs.innerHTML = '';
    };

    const openDebugOverlay = (title) => {
      if (!debugStreamSupported) return;
      clearDebugOverlay();
      debugTitle.textContent = title;
      debugOverlay.classList.add('visible');
      debugOverlay.setAttribute('aria-hidden', 'false');
    };

    const closeDebugOverlay = () => {
      if (activeDebugStream) {
        activeDebugStream.close();
        activeDebugStream = null;
      }
      if (!debugOverlay) return;
      debugOverlay.classList.remove('visible');
      debugOverlay.setAttribute('aria-hidden', 'true');
    };

    const pushCommand = (text) => {
      if (!debugEnabled || !debugCommands) return;
      const row = document.createElement('div');
      row.className = 'command';
      row.textContent = text;
      debugCommands.appendChild(row);
      debugCommands.scrollTop = debugCommands.scrollHeight;
    };

    const pushLog = (text, tag = 'LOG') => {
      if (!debugEnabled || !debugLogs) return;
      const row = document.createElement('div');
      row.className = 'debug-log-line';
      const badge = document.createElement('span');
      badge.className = 'tag';
      badge.textContent = tag;
      const body = document.createElement('span');
      body.className = 'text';
      body.textContent = text;
      row.appendChild(badge);
      row.appendChild(body);
      debugLogs.appendChild(row);
      debugLogs.scrollTop = debugLogs.scrollHeight;
    };

    const statusClassFor = (status) => {
      const s = (status || '').toLowerCase();
      if (s === 'running') return 'status-running';
      if (s === 'restarting') return 'status-restarting';
      if (s === 'paused') return 'status-paused';
      if (s === 'exited' || s === 'stopped') return 'status-exited';
      return 'status-paused';
    };

    const syncActionButtons = (row) => {
      const status = (row?.dataset.containerStatus || '').toLowerCase();
      const isRunning = status === 'running' || status === 'restarting';
      const isPaused = status === 'paused';

      const startBtn = row?.querySelector('[data-action="start"]');
      const stopBtn = row?.querySelector('[data-action="stop"]');
      const pauseBtn = row?.querySelector('[data-action="pause"]');
      const unpauseBtn = row?.querySelector('[data-action="unpause"]');

      if (startBtn) startBtn.classList.toggle('hidden', isRunning || isPaused);
      if (stopBtn) stopBtn.classList.toggle('hidden', !isRunning && !isPaused);
      if (pauseBtn) pauseBtn.classList.toggle('hidden', !isRunning || isPaused);
      if (unpauseBtn) unpauseBtn.classList.toggle('hidden', !isPaused);
    };

    const renderNetworks = (networks = []) => {
      if (!networks.length) return '<span class="meta">Nessuna rete</span>';
      return '<div class="meta">' + networks.map((net) => `<div>${net.name}${net.ip ? ' – ' + net.ip : ''}</div>`).join('') + '</div>';
    };

    const renderPorts = (ports = {}) => {
      if (ports.mode === 'host') return '<div class="meta">Modalità host</div>';
      if (ports.bindings && ports.bindings.length) {
        return `<div class="meta">${ports.bindings.map((p) => `<div>${p}</div>`).join('')}</div>`;
      }
      return '<span class="meta">Nessuna porta esposta</span>';
    };

    const setRowFromOverview = (row, info) => {
      if (!row || !info) return;

      clearRowPending(row, false);

      row.dataset.containerStatus = (info.status || '').toLowerCase();
      const statusCell = row.querySelector('[data-field="status"] .status-pill');
      if (statusCell) {
        statusCell.className = `status-pill ${statusClassFor(info.status)}`;
        statusCell.textContent = info.status;
      }

      const uptimeCell = row.querySelector('[data-field="uptime"]');
      if (uptimeCell) uptimeCell.textContent = info.uptime || '-';

      const cpuCell = row.querySelector('[data-field="cpu"]');
      if (cpuCell) cpuCell.textContent = `${info.cpu_percent ?? '-'}%`;

      const ramCell = row.querySelector('[data-field="ram"]');
      if (ramCell) ramCell.textContent = `${info.mem_usage || '-'} (${info.mem_percent ?? '-'}%)`;

      const restartCell = row.querySelector('[data-field="restart"]');
      if (restartCell) restartCell.textContent = info.restarts ?? '-';

      const networksCell = row.querySelector('[data-field="networks"]');
      if (networksCell) networksCell.innerHTML = renderNetworks(info.networks);

      const portsCell = row.querySelector('[data-field="ports"]');
      if (portsCell) portsCell.innerHTML = renderPorts(info.ports);

      syncActionButtons(row);
    };

    const setRowPending = (row, label = 'In corso...') => {
      if (!row) return;
      row.dataset.pending = '1';
      row.querySelectorAll('[data-action-btn]').forEach((btn) => {
        btn.disabled = true;
        btn.classList.add('loading');
      });

      const statusCell = row.querySelector('[data-field="status"] .status-pill');
      if (!statusCell) return;
      statusCell.dataset.prevText = statusCell.textContent;
      statusCell.dataset.prevClass = statusCell.className;
      statusCell.className = 'status-pill status-pending';
      statusCell.textContent = label;
      const spin = document.createElement('span');
      spin.className = 'spinner';
      statusCell.prepend(spin);
    };

    const clearRowPending = (row, restoreStatus = false) => {
      if (!row) return;
      row.dataset.pending = '';
      row.querySelectorAll('[data-action-btn]').forEach((btn) => {
        btn.disabled = false;
        btn.classList.remove('loading');
      });

      const statusCell = row.querySelector('[data-field="status"] .status-pill');
      if (!statusCell) return;
      const prevText = statusCell.dataset.prevText;
      const prevClass = statusCell.dataset.prevClass;
      const spinner = statusCell.querySelector('.spinner');
      if (spinner) spinner.remove();
      if (restoreStatus && prevText) {
        statusCell.textContent = prevText;
        statusCell.className = prevClass || 'status-pill';
      }
      delete statusCell.dataset.prevText;
      delete statusCell.dataset.prevClass;
    };

    const removeRow = (row) => {
      if (!row) return;
      const id = row.dataset.containerId;
      selectedContainers.delete(id);
      rowIndex.delete(id);
      row.remove();
      updateBulkBar();
    };

    const fetchContainerAction = async (id, action) => {
      const res = await fetch(`/api/containers/${id}/${action}`, { method: 'POST', headers: { Accept: 'application/json' } });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(text || 'Request failed');
      }
      return res.json();
    };

    const startActionDebugStream = (containerId, action, row) => {
      if (!debugStreamSupported) return Promise.reject(new Error('Debug non attivo'));

      return new Promise((resolve, reject) => {
        const name = row?.dataset.containerName || 'Container';
        openDebugOverlay(`${action.toUpperCase()} – ${name}`);
        pushCommand(`Richiesta ${action} per ${name}`);

        const source = new EventSource(`/api/containers/${containerId}/actions/${action}/stream`);
        activeDebugStream = source;
        let lastResult = null;
        let ended = false;

        source.addEventListener('command', (evt) => {
          const data = safeParseEvent(evt);
          if (data?.message) pushCommand(data.message);
        });

        source.addEventListener('status', (evt) => {
          const data = safeParseEvent(evt);
          if (data?.state) pushLog(`Stato: ${data.state}`, 'STAT');
        });

        source.addEventListener('log', (evt) => {
          const data = safeParseEvent(evt);
          if (data?.line) pushLog(data.line, 'LOG');
        });

        source.addEventListener('result', (evt) => {
          const data = safeParseEvent(evt);
          lastResult = data;
          applyActionResult(row, data);
        });

        source.addEventListener('end', (evt) => {
          ended = true;
          const data = safeParseEvent(evt);
          pushLog('Stream concluso', 'DONE');
          source.close();
          activeDebugStream = null;
          resolve(lastResult || data);
        });

        source.addEventListener('error', () => {
          pushLog('Stream interrotto', 'ERR');
          source.close();
          activeDebugStream = null;
          if (!ended) reject(new Error('Stream interrotto'));
        });
      });
    };

    const applyActionResult = (row, data) => {
      if (!row) return;
      if (data?.removed) {
        removeRow(row);
        return;
      }
      if (data?.container) {
        setRowFromOverview(row, data.container);
      } else {
        clearRowPending(row, true);
      }
    };

    const handleContainerAction = async (containerId, action) => {
      const row = rowIndex.get(containerId);
      setRowPending(row, actionPendingLabels[action] || 'In corso...');

      if (debugStreamSupported) {
        try {
          await startActionDebugStream(containerId, action, row);
          const success = actionSuccessLabels[action] || action;
          showToast(`Container ${success}`, { type: 'success' });
          return;
        } catch (err) {
          console.warn('Debug stream non disponibile, fallback', err);
        }
      }

      try {
        const data = await fetchContainerAction(containerId, action);
        applyActionResult(row, data);
        const success = actionSuccessLabels[action] || action;
        showToast(`Container ${success}`, { type: 'success' });
      } catch (err) {
        console.error(err);
        clearRowPending(row, true);
        showToast("Errore nell'eseguire l'azione", { type: 'error' });
      }
    };

    const showToast = (message, { type = 'info', actions = [] } = {}) => {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.innerHTML = `<div class="toast-message">${message}</div>`;

      if (actions.length) {
        const actionBar = document.createElement('div');
        actionBar.className = 'toast-actions';
        actions.forEach(({ label, onClick }) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = label;
          btn.addEventListener('click', () => {
            onClick?.();
            toast.remove();
          });
          actionBar.appendChild(btn);
        });
        toast.appendChild(actionBar);
      }

      toastContainer.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add('visible'));

      const lifetime = actions.length ? 6500 : 4200;
      setTimeout(() => {
        toast.classList.remove('visible');
        setTimeout(() => toast.remove(), 350);
      }, lifetime);
    };

    const updateBulkBar = () => {
      const count = selectedContainers.size;
      bulkCount.textContent = count;
      const visible = count > 0;
      bulkBar.classList.toggle('visible', visible);
      bulkBar.setAttribute('aria-hidden', visible ? 'false' : 'true');
    };

    const toggleSelection = (input) => {
      const id = input.value;
      if (!id) return;
      if (input.checked) {
        selectedContainers.set(id, input.dataset.containerName || 'Container');
      } else {
        selectedContainers.delete(id);
      }
      updateBulkBar();
    };

    selectionInputs.forEach((input) => {
      input.addEventListener('change', (e) => {
        toggleSelection(e.target);
        e.stopPropagation();
      });
      input.addEventListener('click', (e) => e.stopPropagation());
    });

    const performBulkAction = async (action) => {
      const ids = Array.from(selectedContainers.keys());
      if (!ids.length) return;

      const rows = ids.map((id) => rowIndex.get(id)).filter(Boolean);
      rows.forEach((row) => setRowPending(row, actionPendingLabels[action] || 'In corso...'));

      const labelMap = {
        start: 'avvio',
        stop: 'stop',
        restart: 'riavvio',
        delete: 'eliminazione',
        pause: 'pausa',
        unpause: 'ripresa',
      };

      try {
        if (debugStreamSupported) {
          for (const id of ids) {
            const row = rowIndex.get(id);
            await startActionDebugStream(id, action, row);
          }
          showToast(`Azione di ${labelMap[action] || action} completata`, { type: 'success' });
        } else {
          const results = await Promise.all(ids.map((id) => fetchContainerAction(id, action)));
          results.forEach((data, idx) => applyActionResult(rows[idx], data));
          showToast(`Azione di ${labelMap[action] || action} completata`, { type: 'success' });
        }
      } catch (err) {
        console.error(err);
        rows.forEach((row) => clearRowPending(row, true));
        showToast("Errore nell'eseguire l'azione selezionata", { type: 'error' });
      }

      selectedContainers.clear();
      selectionInputs.forEach((input) => {
        input.checked = false;
      });
      updateBulkBar();
    };

    const formatBytes = (bytes) => {
      if (bytes === 0) return '0B';
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      return `${(bytes / Math.pow(1024, i)).toFixed(1)}${sizes[i]}`;
    };

    const drawSpark = (canvas, data, color, maxValue = null) => {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      if (!data.length) return;
      const maxVal = maxValue || Math.max(...data, 1);
      const step = w / Math.max(data.length - 1, 1);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      data.forEach((val, idx) => {
        const x = idx * step;
        const y = h - (val / maxVal) * (h - 10);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
    };

    const setPanel = (name) => {
      tabButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === name));
      tabPanels.forEach(panel => panel.classList.toggle('active', panel.dataset.panel === name));
    };

    const handleTabChange = (name) => {
      setPanel(name);
      activeTab = name;

      if (window.d2haSettings?.performanceMode) {
        stopPolling();
        if (name === 'stats') {
          updateStats();
          statsInterval = setInterval(updateStats, statsIntervalMs);
        }
        if (name === 'logs') {
          updateLogs();
          if (logAuto.checked) {
            logsInterval = setInterval(updateLogs, logsIntervalMs);
          }
        }
      }
    };

    const renderList = (target, items, formatter, emptyText = 'Nessun dato') => {
      if (!items || !items.length) {
        target.textContent = emptyText;
        return;
      }
      target.innerHTML = items.map(formatter).join('');
    };

    const renderTable = (table, items) => {
      table.innerHTML = '';
      if (!items || !items.length) {
        table.innerHTML = '<tr><td class="muted">Nessun dato</td></tr>';
        return;
      }
      items.forEach(item => {
        const row = document.createElement('tr');
        const k = document.createElement('td');
        k.textContent = item.key;
        const v = document.createElement('td');
        v.textContent = item.value;
        row.appendChild(k);
        row.appendChild(v);
        table.appendChild(row);
      });
    };

    const fetchJSON = async (url, options = {}) => {
      const res = await fetch(url, options);
      if (!res.ok) throw new Error('Request failed');
      return res.json();
    };

    const updateDetails = async () => {
      if (!currentContainerId) return;
      try {
        const data = await fetchJSON(`/api/containers/${currentContainerId}/details`);
        modalSubtitle.textContent = data.id;
        document.getElementById('info-status').textContent = data.status;
        document.getElementById('info-uptime').textContent = data.uptime || '-';
        document.getElementById('info-restart').textContent = data.restart_policy || '-';
        document.getElementById('info-image').textContent = data.image;
        document.getElementById('info-short-id').textContent = data.short_id;
        document.getElementById('info-command').textContent = data.command || '-';

        const networks = document.getElementById('info-networks');
        renderList(networks, data.networks, (n) => `<div class="chip">${n.name}${n.ip ? ' – ' + n.ip : ''}</div>`);

        const ports = document.getElementById('info-ports');
        const portVals = data.ports && data.ports.bindings ? data.ports.bindings : [];
        renderList(ports, portVals, (p) => `<div class="chip">${p}</div>`, 'Nessuna porta esposta');

        const volumes = document.getElementById('info-volumes');
        renderList(
          volumes,
          data.mounts,
          (m) => `<div class="chip">${m.source || '-'} → ${m.destination || '-'}</div>`,
          'Nessun volume'
        );

        renderTable(document.getElementById('info-env'), data.env);
        renderTable(document.getElementById('info-labels'), data.labels);
      } catch (err) {
        console.error(err);
      }
    };

    const updateStats = async () => {
      if (!currentContainerId) return;
      try {
        const data = await fetchJSON(`/api/containers/${currentContainerId}/stats`);
        const cpuText = `${data.cpu_percent}%`;
        const memText = `${formatBytes(data.mem_usage)} / ${formatBytes(data.mem_limit || 1)} (${data.mem_percent}%)`;
        const netDelta = lastNet
          ? { rx: Math.max(data.net_rx - lastNet.rx, 0), tx: Math.max(data.net_tx - lastNet.tx, 0) }
          : { rx: 0, tx: 0 };
        lastNet = { rx: data.net_rx, tx: data.net_tx };
        const netText = `↓ ${formatBytes(netDelta.rx)} · ↑ ${formatBytes(netDelta.tx)}`;

        document.getElementById('stat-cpu').textContent = cpuText;
        document.getElementById('stat-ram').textContent = memText;
        document.getElementById('stat-net').textContent = netText;

        statsHistory.cpu.push(data.cpu_percent);
        statsHistory.ram.push(data.mem_percent);
        statsHistory.net.push(netDelta.rx + netDelta.tx);
        statsHistory.cpu = statsHistory.cpu.slice(-statsSampleLimit);
        statsHistory.ram = statsHistory.ram.slice(-statsSampleLimit);
        statsHistory.net = statsHistory.net.slice(-statsSampleLimit);

        drawSpark(document.getElementById('chart-cpu'), statsHistory.cpu, '#31c4ff', 100);
        drawSpark(document.getElementById('chart-ram'), statsHistory.ram, '#8ef0c5', 100);
        drawSpark(document.getElementById('chart-net'), statsHistory.net, '#ffbf69');
      } catch (err) {
        console.error(err);
      }
    };

    const escapeHtml = (str) =>
      str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const getLogLevel = (line) => {
      const upper = line.toUpperCase();
      if (upper.includes('ERROR') || upper.includes('ERR')) return 'log-error';
      if (upper.includes('WARN')) return 'log-warn';
      if (upper.includes('DEBUG')) return 'log-debug';
      if (upper.includes('INFO')) return 'log-info';
      return 'log-other';
    };

    const matchesSeverity = (line, filter) => {
      if (filter === 'all') return true;
      const levelMap = {
        'log-error': 'error',
        'log-warn': 'warn',
        'log-info': 'info',
        'log-debug': 'debug',
        'log-other': 'other',
      };
      const levelClass = getLogLevel(line);
      return levelMap[levelClass] === filter;
    };

    const renderLogs = (logs, target = logOutput) => {
      if (!logs) {
        target.textContent = 'Nessun log disponibile';
        return;
      }

      const lines = logs.split(/\r?\n/);
      const filteredLines = lines
        .filter((line) => line !== '')
        .filter((line) => matchesSeverity(line, logSeverity.value));
      const html = filteredLines
        .map((line) => {
          const levelClass = getLogLevel(line);
          return `<div class="log-line ${levelClass}"><span class="log-bullet">•</span><span>${escapeHtml(line)}</span></div>`;
        })
        .join('');

      target.innerHTML = html || '<div class="muted">Nessun log per la severità selezionata</div>';
    };

    const updateLogs = async () => {
      if (!currentContainerId) return;
      try {
        const tail = logTail.value;
        const data = await fetchJSON(`/api/containers/${currentContainerId}/logs?tail=${tail}`);
        lastLogs = data.logs;
        renderLogs(lastLogs);
      } catch (err) {
        logOutput.textContent = 'Impossibile recuperare i log';
      }
    };

    const updateUpdates = async (force = false) => {
      if (!currentContainerId) return;
      try {
        const url = `/api/containers/${currentContainerId}/updates`;
        const data = await fetchJSON(url, force ? { method: 'POST' } : {});
        document.getElementById('updates-image').textContent = data.image_ref;
        document.getElementById('updates-repo').href = data.repo_link || '#';
        const installedDisplay =
          data.installed_display_version ||
          data.installed_version ||
          data.installed_tag ||
          data.installed_id_short;
        document.getElementById('updates-installed').textContent = installedDisplay || '-';
        const remoteDisplay =
          data.remote_display_version ||
          data.remote_version ||
          data.remote_tag ||
          data.remote_id_short;
        document.getElementById('updates-remote').textContent = remoteDisplay || '-';
        document.getElementById('updates-state').textContent = data.update_state;
        updatesFrequency.value = data.frequency_minutes?.toString() || '60';
        updatesFeedback.textContent = '';
        return data;
      } catch (err) {
        updatesFeedback.textContent = 'Impossibile recuperare le informazioni';
        return null;
      }
    };

    const installUpdates = async () => {
      if (!currentContainerId) return;
      showToast('Installazione aggiornamento in corso...', { type: 'info' });
      try {
        const res = await fetch(`/api/containers/${currentContainerId}/full_update`, { method: 'POST' });
        if (!res.ok) throw new Error('fail');
        showToast('Aggiornamento avviato', { type: 'success' });
        await updateUpdates(true);
      } catch (err) {
        showToast('Impossibile avviare l\'aggiornamento', { type: 'error' });
      }
    };

    const startPolling = () => {
      clearInterval(statsInterval);
      clearInterval(logsInterval);
      statsInterval = setInterval(updateStats, statsIntervalMs);
      if (logAuto.checked) {
        logsInterval = setInterval(updateLogs, logsIntervalMs);
      }
    };

    const stopPolling = () => {
      clearInterval(statsInterval);
      clearInterval(logsInterval);
    };

    const openModal = (id, name, initialTab = 'info') => {
      currentContainerId = id;
      modalTitle.textContent = name;
      statsHistory = { cpu: [], ram: [], net: [] };
      lastNet = null;
      modalEl.classList.add('visible');
      modalEl.setAttribute('aria-hidden', 'false');
      activeTab = initialTab;
      setPanel(initialTab);
      updateDetails();
      updateUpdates();
      if (window.d2haSettings?.performanceMode) {
        if (initialTab === 'stats') {
          updateStats();
          statsInterval = setInterval(updateStats, statsIntervalMs);
        }
        if (initialTab === 'logs') {
          updateLogs();
          if (logAuto.checked) {
            logsInterval = setInterval(updateLogs, logsIntervalMs);
          }
        }
      } else {
        updateStats();
        updateLogs();
        startPolling();
      }
    };

    const closeModal = () => {
      stopPolling();
      modalEl.classList.remove('visible');
      modalEl.setAttribute('aria-hidden', 'true');
      currentContainerId = null;
      lastLogs = '';
    };

    window.registerPerformanceHandler?.((enabled) => {
      statsIntervalMs = enabled ? pollingPerformance.statsIntervalMs : pollingDefaults.statsIntervalMs;
      logsIntervalMs = enabled ? pollingPerformance.logsIntervalMs : pollingDefaults.logsIntervalMs;
      statsSampleLimit = enabled ? pollingPerformance.historyLimit : pollingDefaults.historyLimit;
      statsHistory.cpu = statsHistory.cpu.slice(-statsSampleLimit);
      statsHistory.ram = statsHistory.ram.slice(-statsSampleLimit);
      statsHistory.net = statsHistory.net.slice(-statsSampleLimit);

      if (!modalEl.classList.contains('visible')) {
        stopPolling();
        return;
      }

      if (enabled) {
        stopPolling();
        if (activeTab === 'stats') {
          updateStats();
          statsInterval = setInterval(updateStats, statsIntervalMs);
        }
        if (activeTab === 'logs' && logAuto.checked) {
          updateLogs();
          logsInterval = setInterval(updateLogs, logsIntervalMs);
        }
      } else {
        updateStats();
        updateLogs();
        startPolling();
      }
    });

    document.getElementById('modal-close').addEventListener('click', closeModal);
    modalEl.addEventListener('click', (e) => {
      if (e.target === modalEl) closeModal();
    });

    debugClose?.addEventListener('click', closeDebugOverlay);
    debugClear?.addEventListener('click', clearDebugOverlay);
    debugOverlay?.addEventListener('click', (e) => {
      if (e.target === debugOverlay) closeDebugOverlay();
    });

    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => handleTabChange(btn.dataset.tab));
    });

    document.querySelectorAll('[data-open-modal]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const targetTab = btn.dataset.tab || 'info';
        openModal(btn.dataset.containerId, btn.dataset.containerName, targetTab);
      });
    });

    actionButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const row = btn.closest('tr[data-container-id]');
        const id = row?.dataset.containerId;
        if (!id) return;
        handleContainerAction(id, btn.dataset.action);
      });
    });

    rowIndex.forEach((row) => syncActionButtons(row));

    bulkButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        performBulkAction(btn.dataset.bulkAction);
      });
    });

    logRefreshBtn.addEventListener('click', () => {
      updateLogs();
    });

    logSeverity.addEventListener('change', () => renderLogs(lastLogs));

    logAuto.addEventListener('change', () => {
      if (logAuto.checked) {
        logsInterval = setInterval(updateLogs, logsIntervalMs);
      } else {
        clearInterval(logsInterval);
      }
    });

    updatesSave.addEventListener('click', async () => {
      if (!currentContainerId) return;
      try {
        const minutes = parseInt(updatesFrequency.value, 10) || 60;
        const data = await fetchJSON(`/api/containers/${currentContainerId}/updates/frequency`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ minutes })
        });
        updatesFeedback.textContent = `Frequenza salvata (${data.minutes} min)`;
      } catch (err) {
        updatesFeedback.textContent = 'Errore nel salvataggio';
      }
    });

    updatesCheck.addEventListener('click', async () => {
      updatesFeedback.textContent = 'Verifica in corso...';
      const data = await updateUpdates(true);
      updatesFeedback.textContent = 'Verifica completata';
      if (!data) return;

      if (data.update_state === 'up_to_date') {
        showToast('Il container è già aggiornato', { type: 'success' });
      } else if (data.update_state === 'update_available') {
        showToast('Aggiornamento disponibile. Vuoi installarlo?', {
          type: 'warning',
          actions: [
            { label: 'Installa', onClick: installUpdates },
            { label: 'Annulla' },
          ],
        });
      }
    });

  </script>
</body>

</html>