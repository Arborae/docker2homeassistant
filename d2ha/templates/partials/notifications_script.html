<script>
(() => {
    const initialNotifications = {{ notifications|default({})|tojson }} || {};
    const notifListEl = document.getElementById('notifList');
    const notifBadgeEl = document.getElementById('notifBadge');
    const notifPanelEl = document.getElementById('notifPanel');
    const notifToggleEl = document.getElementById('notifToggle');
    const settingsPanelEl = document.getElementById('settingsPanel');
    const settingsToggleEl = document.getElementById('settingsToggle');
    const headerClockEl = document.getElementById('header-clock');
    const backendStatusEl = document.getElementById('backend-status-indicator');
    const backendStatusModalEl = document.getElementById('backend-status-modal');
    const backendStatusLastUpdateEl = document.getElementById('backend-status-last-update');
    const backendRefreshBtn = document.getElementById('backend-status-refresh-btn');
    const backendCloseBtn = document.getElementById('backend-status-close-btn');
    const backendText = {
      lastUpdate: "{{ t('backend_status.last_update') }}",
      noRecent: "{{ t('backend_status.no_recent_update') }}",
    };
    const safeModeToggleEl = document.getElementById('safeModeToggle');
    const performanceModeToggleEl = document.getElementById('performance-mode-toggle');
    const debugModeToggleEl = document.getElementById('debug-mode-toggle');
    const safeConfirmState = {
      modal: null,
      message: null,
      confirmBtn: null,
      cancelBtn: null,
      pendingForm: null,
    };
    let safeModeEnabled = (document.body.dataset.safeMode || '0') === '1';
    const initialPerformanceMode = (document.body?.dataset?.performanceMode || '0') === '1';
    const initialDebugMode = (document.body?.dataset?.debugMode || '0') === '1';
    const existingSettings = window.d2haSettings || {};
    window.d2haSettings = {
      ...existingSettings,
      performanceMode: existingSettings.performanceMode ?? initialPerformanceMode,
      debugMode: existingSettings.debugMode ?? initialDebugMode,
    };
    window.d2haRuntime = window.d2haRuntime || { performanceHandlers: [] };
    const performanceState = window.d2haSettings;
    let currentNotifications = initialNotifications;
    let dismissedNotifications = {};
    let clockInterval = null;
    let lastSuccessfulPing = null;
    let consecutiveErrors = 0;
    let backendPingTimer = null;

    function formatClock(dateObj) {
      const pad = (v) => String(v).padStart(2, '0');
      return `${pad(dateObj.getHours())}:${pad(dateObj.getMinutes())}:${pad(dateObj.getSeconds())}`;
    }

    function startClock() {
      if (!headerClockEl) return;
      clearInterval(clockInterval);

      const updateClock = () => {
        const now = new Date();
        headerClockEl.textContent = formatClock(now);
      };

      updateClock();
      clockInterval = setInterval(updateClock, 1000);
    }

    function syncPerformanceToggle(enabled) {
      if (performanceModeToggleEl) {
        performanceModeToggleEl.checked = enabled;
      }
    }

    function updatePerformanceMode(enabled) {
      performanceState.performanceMode = !!enabled;
      syncPerformanceToggle(performanceState.performanceMode);
      applyPerformanceMode(performanceState.performanceMode);
    }

    async function loadPerformanceMode() {
      try {
        const res = await fetch('/api/performance_mode');
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updatePerformanceMode(!!data.enabled);
      } catch (err) {
        console.warn('Unable to load performance mode from backend', err);
      }
    }

    async function persistPerformanceMode(enabled) {
      try {
        const res = await fetch('/api/performance_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled }),
        });
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updatePerformanceMode(!!data.enabled);
      } catch (err) {
        console.error('Impossibile aggiornare la modalità prestazioni', err);
        if (performanceModeToggleEl) {
          performanceModeToggleEl.checked = performanceState.performanceMode;
        }
        alert('Impossibile aggiornare la modalità prestazioni');
      }
    }

    function initPerformanceMode() {
      updatePerformanceMode(initialPerformanceMode);

      if (performanceModeToggleEl) {
        performanceModeToggleEl.addEventListener('change', () => {
          persistPerformanceMode(performanceModeToggleEl.checked);
        });
      }

      loadPerformanceMode();
    }

    function syncDebugToggle(enabled) {
      if (debugModeToggleEl) {
        debugModeToggleEl.checked = enabled;
      }
    }

    function updateDebugMode(enabled) {
      performanceState.debugMode = !!enabled;
      document.body.dataset.debugMode = performanceState.debugMode ? '1' : '0';
      syncDebugToggle(performanceState.debugMode);
      document.dispatchEvent(
        new CustomEvent('debug-mode-changed', { detail: { enabled: performanceState.debugMode } })
      );
    }

    async function loadDebugMode() {
      try {
        const res = await fetch('/api/debug_mode');
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updateDebugMode(!!data.enabled);
      } catch (err) {
        console.warn('Unable to load debug mode from backend', err);
      }
    }

    async function persistDebugMode(enabled) {
      try {
        const res = await fetch('/api/debug_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled }),
        });
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updateDebugMode(!!data.enabled);
      } catch (err) {
        console.error('Impossibile aggiornare la modalità debug', err);
        if (debugModeToggleEl) {
          debugModeToggleEl.checked = performanceState.debugMode;
        }
        alert('Impossibile aggiornare la modalità debug');
      }
    }

    function initDebugMode() {
      updateDebugMode(initialDebugMode);

      if (debugModeToggleEl) {
        debugModeToggleEl.addEventListener('change', () => {
          persistDebugMode(debugModeToggleEl.checked);
        });
      }

      loadDebugMode();
    }

    function updateSafeModeState(enabled) {
      safeModeEnabled = !!enabled;
      document.body.dataset.safeMode = safeModeEnabled ? '1' : '0';
      if (safeModeToggleEl) {
        safeModeToggleEl.checked = safeModeEnabled;
      }
      window.d2haSafeMode = { enabled: safeModeEnabled };
      document.dispatchEvent(new CustomEvent('safe-mode-changed', { detail: { enabled: safeModeEnabled } }));
    }

    function registerPerformanceHandler(handler) {
      if (typeof handler !== 'function') return;
      window.d2haRuntime.performanceHandlers.push(handler);
      try {
        handler(!!performanceState.performanceMode);
      } catch (err) {
        console.error('Performance handler failed during registration', err);
      }
    }

    function applyPerformanceMode(enabled) {
      performanceState.performanceMode = !!enabled;
      window.d2haRuntime.performanceHandlers.forEach((handler) => {
        try {
          handler(performanceState.performanceMode);
        } catch (err) {
          console.error('Performance handler failed', err);
        }
      });
      document.dispatchEvent(
        new CustomEvent('performance-mode-changed', { detail: { enabled: performanceState.performanceMode } })
      );
    }

    function updateBackendStatus(durationMs) {
      const now = Date.now();
      const age = lastSuccessfulPing ? now - lastSuccessfulPing : Infinity;
      const el = backendStatusEl;
      if (!el) return;

      el.classList.remove('backend-status-ok', 'backend-status-degraded', 'backend-status-down');

      if (consecutiveErrors >= 2 || age > 30000) {
        el.classList.add('backend-status-down');
      } else if (age > 20000 || (durationMs || 0) > 800) {
        el.classList.add('backend-status-degraded');
      } else {
        el.classList.add('backend-status-ok');
      }
    }

    function updateBackendModalText() {
      if (!backendStatusLastUpdateEl) return;
      if (lastSuccessfulPing) {
        backendStatusLastUpdateEl.textContent = backendText.lastUpdate.replace('{timestamp}', formatClock(new Date(lastSuccessfulPing)));
      } else {
        backendStatusLastUpdateEl.textContent = backendText.noRecent;
      }
    }

    function closeBackendModal() {
      backendStatusModalEl?.classList.remove('visible');
    }

    async function pingBackend() {
      const start = performance.now();
      let durationMs = 0;
      backendStatusEl?.classList.add('backend-status-updating');
      try {
        const res = await fetch('/api/overview', { cache: 'no-store' });
        durationMs = performance.now() - start;
        if (!res.ok) throw new Error(`Status ${res.status}`);
        await res.json();
        lastSuccessfulPing = Date.now();
        consecutiveErrors = 0;
        updateBackendStatus(durationMs);
        updateBackendModalText();
      } catch (err) {
        console.error('Backend healthcheck failed', err);
        consecutiveErrors += 1;
        updateBackendStatus(durationMs);
      } finally {
        backendStatusEl?.classList.remove('backend-status-updating');
      }
    }

    function setupBackendStatusModal() {
      if (backendStatusEl) {
        backendStatusEl.addEventListener('click', () => {
          updateBackendModalText();
          backendStatusModalEl?.classList.add('visible');
        });
      }

      backendCloseBtn?.addEventListener('click', closeBackendModal);

      backendStatusModalEl?.addEventListener('click', (evt) => {
        if (evt.target === backendStatusModalEl) {
          closeBackendModal();
        }
      });

      backendRefreshBtn?.addEventListener('click', async () => {
        await pingBackend();
        try {
          if (typeof window.refreshOverview === 'function') {
            window.refreshOverview();
          }
        } catch (err) {
          console.error('Impossibile aggiornare immediatamente i dati', err);
        }
      });
    }

    function startBackendMonitor() {
      pingBackend();
      clearInterval(backendPingTimer);
      backendPingTimer = setInterval(pingBackend, 5000);
    }

    function loadDismissedNotifications() {
      try {
        dismissedNotifications = JSON.parse(localStorage.getItem('d2haDismissedNotifications') || '{}') || {};
      } catch (err) {
        dismissedNotifications = {};
      }
    }

    function ensureSafeConfirmModal() {
      if (safeConfirmState.modal) return;

      const backdrop = document.createElement('div');
      backdrop.className = 'safe-confirm-backdrop';
      backdrop.innerHTML = `
        <div class="safe-confirm-modal" role="dialog" aria-modal="true" aria-labelledby="safe-confirm-title">
          <h3 class="safe-confirm-title" id="safe-confirm-title">Conferma richiesta</h3>
          <p class="safe-confirm-message" data-safe-confirm-message></p>
          <div class="safe-confirm-actions">
            <button type="button" class="btn btn-secondary" data-safe-cancel>Annulla</button>
            <button type="button" class="btn" data-safe-confirm>Procedi</button>
          </div>
        </div>
      `;

      backdrop.addEventListener('click', (evt) => {
        if (evt.target === backdrop) closeSafeConfirmModal();
      });

      const message = backdrop.querySelector('[data-safe-confirm-message]');
      const confirmBtn = backdrop.querySelector('[data-safe-confirm]');
      const cancelBtn = backdrop.querySelector('[data-safe-cancel]');

      confirmBtn?.addEventListener('click', () => {
        if (safeConfirmState.pendingForm) {
          safeConfirmState.pendingForm.submit();
        }
        closeSafeConfirmModal();
      });

      cancelBtn?.addEventListener('click', () => closeSafeConfirmModal());

      safeConfirmState.modal = backdrop;
      safeConfirmState.message = message;
      safeConfirmState.confirmBtn = confirmBtn;
      safeConfirmState.cancelBtn = cancelBtn;

      document.body.appendChild(backdrop);
    }

    function openSafeConfirmModal(message, form) {
      ensureSafeConfirmModal();
      safeConfirmState.pendingForm = form;
      if (safeConfirmState.message) {
        safeConfirmState.message.textContent = message;
      }
      safeConfirmState.modal?.classList.add('visible');
      safeConfirmState.confirmBtn?.focus({ preventScroll: true });
    }

    function closeSafeConfirmModal() {
      safeConfirmState.pendingForm = null;
      safeConfirmState.modal?.classList.remove('visible');
    }

    startClock();

  function saveDismissedNotifications() {
    localStorage.setItem('d2haDismissedNotifications', JSON.stringify(dismissedNotifications));
  }

  function shouldIgnoreNotification(item) {
    const entry = dismissedNotifications[item.id];
    return entry && entry.count >= item.count;
  }

  function updateBadge(count) {
    if (!notifBadgeEl) return;
    if (count > 0) {
      notifBadgeEl.textContent = count;
      notifBadgeEl.style.visibility = 'visible';
    } else {
      notifBadgeEl.textContent = '0';
      notifBadgeEl.style.visibility = 'hidden';
    }
  }

  function dismissNotification(item) {
    dismissedNotifications[item.id] = { count: item.count, ts: Date.now() };
    saveDismissedNotifications();
    renderNotificationList(currentNotifications);
  }

  function attachSwipeToDismiss(element, item) {
    let touchStartX = null;
    element.addEventListener('touchstart', (ev) => {
      touchStartX = ev.changedTouches[0]?.clientX || 0;
    });
    element.addEventListener('touchend', (ev) => {
      if (touchStartX === null) return;
      const delta = (ev.changedTouches[0]?.clientX || 0) - touchStartX;
      if (Math.abs(delta) > 45) {
        dismissNotification(item);
      }
      touchStartX = null;
    });
  }

  function buildNotificationItems(data) {
    const items = [];
    const unused = data?.unused_images || {};
    if (unused.count > 0) {
      items.push({
        id: 'unused-images',
        count: unused.count,
        title: 'Immagini non utilizzate',
        description: `${unused.count} immagini · Spazio liberabile: ${unused.reclaimable_h || '-'}`,
      });
    }

    if ((data?.updates_pending || 0) > 0) {
      const count = data.updates_pending;
      items.push({
        id: 'updates-pending',
        count,
        title: 'Container da aggiornare',
        description: `${count} container non ancora aggiornati`,
      });
    }

    if ((data?.critical_events || 0) > 0) {
      const count = data.critical_events;
      items.push({
        id: 'critical-events',
        count,
        title: 'Eventi critici',
        description: `${count} eventi critici o fatali registrati (ultime 24h)`,
      });
    }

    return items;
  }

  function renderNotificationList(data) {
    currentNotifications = data || {};
    const items = buildNotificationItems(currentNotifications);
    const visible = items.filter((item) => !shouldIgnoreNotification(item));

    if (!notifListEl) return;
    notifListEl.innerHTML = '';

    if (visible.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'notif-empty';
      empty.textContent = 'Nessuna notifica al momento';
      notifListEl.appendChild(empty);
      updateBadge(0);
      return;
    }

    visible.forEach((item) => {
      const row = document.createElement('div');
      row.className = 'notif-item';
      row.dataset.id = item.id;

      const content = document.createElement('div');
      content.className = 'notif-content';

      const title = document.createElement('div');
      title.className = 'notif-title';
      title.textContent = item.title;

      const desc = document.createElement('div');
      desc.className = 'notif-desc';
      desc.textContent = item.description;

      content.appendChild(title);
      content.appendChild(desc);

      const dismissBtn = document.createElement('button');
      dismissBtn.className = 'notif-dismiss';
      dismissBtn.type = 'button';
      dismissBtn.setAttribute('aria-label', 'Ignora notifica');
      dismissBtn.textContent = '×';
      dismissBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        dismissNotification(item);
      });

      row.appendChild(content);
      row.appendChild(dismissBtn);
      attachSwipeToDismiss(row, item);
      notifListEl.appendChild(row);
    });

    updateBadge(visible.length);
  }

  function toggleNotifications(open = null) {
    if (!notifPanelEl || !notifToggleEl) return;
    const shouldOpen = open === null ? !notifPanelEl.classList.contains('open') : open;
    notifPanelEl.classList.toggle('open', shouldOpen);
    notifToggleEl.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    if (shouldOpen && settingsPanelEl) {
      settingsPanelEl.classList.remove('open');
      settingsToggleEl?.setAttribute('aria-expanded', 'false');
    }
  }

  function toggleSettings(open = null) {
    if (!settingsPanelEl || !settingsToggleEl) return;
    const shouldOpen = open === null ? !settingsPanelEl.classList.contains('open') : open;
    settingsPanelEl.classList.toggle('open', shouldOpen);
    settingsToggleEl.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    if (shouldOpen && notifPanelEl) {
      notifPanelEl.classList.remove('open');
      notifToggleEl?.setAttribute('aria-expanded', 'false');
    }
  }

  function setupNotificationToggle() {
    if (!notifToggleEl) return;
    notifToggleEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleNotifications();
    });

    document.addEventListener('click', (ev) => {
      if (!notifPanelEl || !notifToggleEl) return;
      const target = ev.target;
      if (
        notifPanelEl.contains(target) ||
        notifToggleEl.contains(target) ||
        settingsPanelEl?.contains(target) ||
        settingsToggleEl?.contains(target)
      ) {
        return;
      }
      toggleNotifications(false);
      toggleSettings(false);
    });
  }

  function setupSettingsToggle() {
    if (!settingsToggleEl) return;
    settingsToggleEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleSettings();
    });
  }

  async function refreshNotifications() {
    try {
      const res = await fetch('/api/notifications');
      if (!res.ok) return;
      const data = await res.json();
      renderNotificationList(data);
    } catch (err) {
      console.error('Failed to refresh notifications', err);
    }
  }

  async function persistSafeMode(enabled) {
    try {
      const res = await fetch('/api/safe_mode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled }),
      });
      if (!res.ok) throw new Error('Request failed');
      const data = await res.json();
      updateSafeModeState(!!data.enabled);
    } catch (err) {
      console.error('Impossibile aggiornare la modalità sicura', err);
      if (safeModeToggleEl) {
        safeModeToggleEl.checked = safeModeEnabled;
      }
      alert('Impossibile aggiornare la modalità sicura');
    }
  }

    function setupSafeModeToggle() {
      if (!safeModeToggleEl) return;
      safeModeToggleEl.addEventListener('change', () => {
        persistSafeMode(safeModeToggleEl.checked);
      });
    }

    function setupSafeConfirmations() {
      document.addEventListener(
        'submit',
        (ev) => {
          const form = ev.target;
          if (!(form instanceof HTMLFormElement)) return;
          const message = form.dataset.safeConfirm;
          const handledElsewhere = form.dataset.safeModal === 'external';
          if (!message || !safeModeEnabled || handledElsewhere) return;

          ev.preventDefault();
          openSafeConfirmModal(message, form);
        },
        true,
      );
    }

  window.registerPerformanceHandler = registerPerformanceHandler;
  window.applyPerformanceMode = applyPerformanceMode;
  initPerformanceMode();
  initDebugMode();
  loadDismissedNotifications();
  updateSafeModeState(safeModeEnabled);
  renderNotificationList(currentNotifications);
  setupNotificationToggle();
  setupSettingsToggle();
  setupSafeModeToggle();
  setupSafeConfirmations();
  setupBackendStatusModal();
  startBackendMonitor();
  refreshNotifications();
  setInterval(refreshNotifications, 60000);
})();
</script>
