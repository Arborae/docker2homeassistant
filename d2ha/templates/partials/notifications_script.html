<script>
(() => {
    const initialNotifications = {{ notifications|default({})|tojson }} || {};
    const notifListEl = document.getElementById('notifList');
    const notifBadgeEl = document.getElementById('notifBadge');
    const notifPanelEl = document.getElementById('notifPanel');
    const notifToggleEl = document.getElementById('notifToggle');
    const settingsPanelEl = document.getElementById('settingsPanel');
    const settingsToggleEl = document.getElementById('settingsToggle');
    const compactToggleEl = document.getElementById('compact-mode-toggle');
    const navEl = document.getElementById('primaryNav');
    const mobileDrawerTab = document.getElementById('mobileDrawerTab');
    const headerClockEl = document.getElementById('header-clock');
    const headerClockTimeEl = document.getElementById('header-clock-time');
    const headerClockDateEl = document.getElementById('header-clock-date');
    const clockModalEl = document.getElementById('clock-settings-modal');
    const clockAutoToggleEl = document.getElementById('clock-timezone-auto');
    const clockRegionSelectEl = document.getElementById('clock-region-select');
    const clockZoneSelectEl = document.getElementById('clock-zone-select');
    const clockTimezoneSelectsEl = document.getElementById('clock-timezone-selects');
    const clockSecondsToggleEl = document.getElementById('clock-seconds-toggle');
    const clockDateToggleEl = document.getElementById('clock-date-toggle');
    const clockBrowserHintEl = document.getElementById('clock-browser-tz');
    const backendStatusEl = document.getElementById('backend-status-indicator');
    const backendStatusModalEl = document.getElementById('backend-status-modal');
    const backendStatusLastUpdateEl = document.getElementById('backend-status-last-update');
    const backendRefreshBtn = document.getElementById('backend-status-refresh-btn');
    const backendCloseBtn = document.getElementById('backend-status-close-btn');
    const backendText = {
      lastUpdate: "{{ t('backend_status.last_update') }}",
      noRecent: "{{ t('backend_status.no_recent_update') }}",
    };
    const clockText = {
      browserLabel: "{{ t('clock.timezone.browser_label') }}",
      regionPlaceholder: "{{ t('clock.timezone.choose_region') }}",
      zonePlaceholder: "{{ t('clock.timezone.choose_zone') }}",
    };
    const safeModeToggleEl = document.getElementById('safeModeToggle');
    const performanceModeToggleEl = document.getElementById('performance-mode-toggle');
    const debugModeToggleEl = document.getElementById('debug-mode-toggle');
    const compactStorageKey = 'd2haCompactMode';
    let mobileNavBackdrop = null;
    let mobileDrawerOpen = false;
    const safeConfirmState = {
      modal: null,
      message: null,
      confirmBtn: null,
      cancelBtn: null,
      pendingForm: null,
      resolver: null,
    };
    let safeModeEnabled = (document.body.dataset.safeMode || '0') === '1';
    const initialPerformanceMode = (document.body?.dataset?.performanceMode || '0') === '1';
    const initialDebugMode = (document.body?.dataset?.debugMode || '0') === '1';
    const existingSettings = window.d2haSettings || {};
    window.d2haSettings = {
      ...existingSettings,
      performanceMode: existingSettings.performanceMode ?? initialPerformanceMode,
      debugMode: existingSettings.debugMode ?? initialDebugMode,
    };
    window.d2haRuntime = window.d2haRuntime || { performanceHandlers: [] };
    const performanceState = window.d2haSettings;
    let currentNotifications = initialNotifications;
    let dismissedNotifications = {};
    let clockInterval = null;
    let clockPreferences = null;
    const clockStorageKey = 'd2haClockPrefs';
    const handleClockOutsideClick = (evt) => {
      if (!clockModalEl?.classList.contains('visible')) return;
      if (clockModalEl.contains(evt.target) || headerClockEl.contains(evt.target)) return;
      closeClockModal();
    };
    let lastSuccessfulPing = null;
    let consecutiveErrors = 0;
    let backendPingTimer = null;

    function loadCompactPreference() {
      try {
        return localStorage.getItem(compactStorageKey) === '1';
      } catch (err) {
        console.warn('Unable to read compact preference', err);
        return false;
      }
    }

    function saveCompactPreference(enabled) {
      try {
        localStorage.setItem(compactStorageKey, enabled ? '1' : '0');
      } catch (err) {
        console.warn('Unable to persist compact preference', err);
      }
    }

    function applyCompactMode(enabled) {
      const isEnabled = !!enabled;
      document.body.classList.toggle('compact-mode', isEnabled);
      if (compactToggleEl) {
        compactToggleEl.checked = isEnabled;
      }
      document.dispatchEvent(new CustomEvent('compact-mode-changed', { detail: { enabled: isEnabled } }));
    }

    function ensureMobileBackdrop() {
      if (mobileNavBackdrop) return;
      mobileNavBackdrop = document.createElement('div');
      mobileNavBackdrop.className = 'mobile-nav-backdrop';
      document.body.appendChild(mobileNavBackdrop);
      mobileNavBackdrop.addEventListener('click', () => setMobileDrawerState(false));
    }

    function setMobileDrawerState(open) {
      const next = !!open;
      mobileDrawerOpen = next;
      if (mobileDrawerTab) {
        mobileDrawerTab.setAttribute('aria-expanded', next ? 'true' : 'false');
      }
      ensureMobileBackdrop();
      document.body.classList.toggle('mobile-drawer-open', next);
    }

    function toggleMobileDrawer() {
      if (!window.matchMedia('(max-width: 760px)').matches) return;
      setMobileDrawerState(!mobileDrawerOpen);
    }

    function initMobileDrawer() {
      if (!navEl || !mobileDrawerTab) return;
      ensureMobileBackdrop();
      mobileDrawerTab.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMobileDrawer();
      });

      mobileNavBackdrop?.addEventListener('click', () => setMobileDrawerState(false));

      navEl.querySelectorAll('a').forEach((link) => {
        link.addEventListener('click', () => {
          if (window.matchMedia('(max-width: 760px)').matches) {
            setMobileDrawerState(false);
          }
        });
      });

      document.addEventListener('click', (evt) => {
        if (!mobileDrawerOpen) return;
        if (!navEl.contains(evt.target) && evt.target !== mobileDrawerTab) {
          setMobileDrawerState(false);
        }
      });

      document.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape' && mobileDrawerOpen) {
          setMobileDrawerState(false);
        }
      });

      window.addEventListener('resize', () => {
        if (window.innerWidth > 800 && mobileDrawerOpen) {
          setMobileDrawerState(false);
        }
      });
    }

    function initCompactMode() {
      const initialCompact = loadCompactPreference();
      applyCompactMode(initialCompact);

      if (compactToggleEl) {
        compactToggleEl.addEventListener('change', (evt) => {
          const next = !!evt.target.checked;
          applyCompactMode(next);
          saveCompactPreference(next);
        });
      }
    }

    function getBrowserTimeZone() {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (err) {
        console.warn('Unable to detect browser timezone', err);
        return 'UTC';
      }
    }

    function loadClockPreferences() {
      const defaults = { autoTimezone: true, timezone: '', showSeconds: true, showDate: true };
      try {
        const saved = JSON.parse(localStorage.getItem(clockStorageKey) || '{}');
        return { ...defaults, ...saved };
      } catch (err) {
        console.warn('Unable to parse clock preferences', err);
        return { ...defaults };
      }
    }

    function saveClockPreferences(next) {
      try {
        localStorage.setItem(clockStorageKey, JSON.stringify(next));
      } catch (err) {
        console.warn('Unable to persist clock preferences', err);
      }
    }

    function getSupportedTimeZones() {
      if (typeof Intl.supportedValuesOf === 'function') {
        return Intl.supportedValuesOf('timeZone');
      }
      return [
        'UTC',
        'Europe/Rome',
        'Europe/Berlin',
        'Europe/Madrid',
        'Europe/London',
        'America/New_York',
        'America/Los_Angeles',
        'America/Sao_Paulo',
        'Asia/Tokyo',
        'Asia/Shanghai',
        'Asia/Dubai',
        'Australia/Sydney',
        'Africa/Johannesburg',
      ];
    }

    function groupTimeZonesByRegion() {
      const allZones = getSupportedTimeZones();
      return allZones.reduce((acc, tz) => {
        const [region, city] = tz.split('/');
        if (!city) return acc;
        if (!acc[region]) acc[region] = [];
        acc[region].push(tz);
        return acc;
      }, {});
    }

    const timeZoneGroups = groupTimeZonesByRegion();

    function populateRegionSelect(selectedRegion) {
      if (!clockRegionSelectEl) return;
      const regions = Object.keys(timeZoneGroups).sort();
      clockRegionSelectEl.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = `— ${clockText.regionPlaceholder} —`;
      clockRegionSelectEl.appendChild(placeholder);

      regions.forEach((region) => {
        const opt = document.createElement('option');
        opt.value = region;
        opt.textContent = region;
        if (region === selectedRegion) opt.selected = true;
        clockRegionSelectEl.appendChild(opt);
      });
    }

    function populateZoneSelect(region, selectedZone) {
      if (!clockZoneSelectEl) return;
      const zones = timeZoneGroups[region] || [];
      clockZoneSelectEl.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = `— ${clockText.zonePlaceholder} —`;
      clockZoneSelectEl.appendChild(placeholder);

      zones.forEach((zone) => {
        const [, city] = zone.split('/');
        const opt = document.createElement('option');
        opt.value = zone;
        opt.textContent = city?.replace(/_/g, ' ') || zone;
        if (zone === selectedZone) opt.selected = true;
        clockZoneSelectEl.appendChild(opt);
      });
    }

    function formatClock(dateObj, { timeZone = getBrowserTimeZone(), showSeconds = true } = {}) {
      const options = {
        hour: '2-digit',
        minute: '2-digit',
        ...(showSeconds ? { second: '2-digit' } : {}),
        hour12: false,
        timeZone,
      };
      return new Intl.DateTimeFormat(undefined, options).format(dateObj);
    }

    function formatDate(dateObj, timeZone) {
      return new Intl.DateTimeFormat('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        timeZone,
      }).format(dateObj);
    }

    function getActiveTimeZone() {
      const browserTz = getBrowserTimeZone();
      if (!clockPreferences) return browserTz;
      if (clockPreferences.autoTimezone) return browserTz;
      return clockPreferences.timezone || browserTz;
    }

    function updateClockDisplay() {
      if (!headerClockEl) return;
      const timeZone = getActiveTimeZone();
      const now = new Date();
      const timeStr = formatClock(now, { timeZone, showSeconds: !!clockPreferences?.showSeconds });
      const dateStr = formatDate(now, timeZone);

      if (headerClockTimeEl) {
        headerClockTimeEl.textContent = timeStr;
      } else {
        headerClockEl.textContent = timeStr;
      }

      if (headerClockDateEl) {
        if (clockPreferences?.showDate) {
          headerClockDateEl.textContent = dateStr;
          headerClockDateEl.style.display = 'block';
        } else {
          headerClockDateEl.style.display = 'none';
        }
      }
    }

    function startClock() {
      if (!headerClockEl) return;
      clearInterval(clockInterval);
      updateClockDisplay();
      const intervalMs = clockPreferences?.showSeconds ? 1000 : 10000;
      clockInterval = setInterval(updateClockDisplay, intervalMs);
    }

    function syncClockControls() {
      if (!clockPreferences) return;

      const browserTz = getBrowserTimeZone();
      const manualTz = clockPreferences.timezone || getActiveTimeZone();
      const [manualRegion] = (manualTz || '').split('/');

      if (clockBrowserHintEl) {
        clockBrowserHintEl.textContent = `${clockText.browserLabel} ${browserTz}`;
      }

      if (clockAutoToggleEl) clockAutoToggleEl.checked = !!clockPreferences.autoTimezone;
      if (clockSecondsToggleEl) clockSecondsToggleEl.checked = !!clockPreferences.showSeconds;
      if (clockDateToggleEl) clockDateToggleEl.checked = !!clockPreferences.showDate;

      populateRegionSelect(manualRegion);
      populateZoneSelect(manualRegion, clockPreferences.timezone);

      const disableManual = !!clockPreferences.autoTimezone;
      [clockRegionSelectEl, clockZoneSelectEl].forEach((el) => {
        if (el) {
          el.disabled = disableManual;
        }
      });
      if (clockTimezoneSelectsEl) {
        clockTimezoneSelectsEl.classList.toggle('disabled', disableManual);
        clockTimezoneSelectsEl.setAttribute('aria-disabled', disableManual ? 'true' : 'false');
      }
    }

    function applyClockPreference(partial, options = {}) {
      clockPreferences = { ...clockPreferences, ...partial };
      saveClockPreferences(clockPreferences);
      if (!options.skipSync) {
        syncClockControls();
      }
      startClock();
    }

    function openClockModal() {
      if (!clockModalEl) return;
      clockModalEl.classList.add('visible');
      clockModalEl.setAttribute('aria-hidden', 'false');
      headerClockEl?.setAttribute('aria-expanded', 'true');
      headerClockEl?.classList.add('settings-open');
      document.addEventListener('click', handleClockOutsideClick, true);
    }

    function closeClockModal() {
      if (!clockModalEl) return;
      clockModalEl.classList.remove('visible');
      clockModalEl.setAttribute('aria-hidden', 'true');
      headerClockEl?.setAttribute('aria-expanded', 'false');
      headerClockEl?.classList.remove('settings-open');
      document.removeEventListener('click', handleClockOutsideClick, true);
    }

    function initClockSettings() {
      if (!headerClockEl) return;
      clockPreferences = loadClockPreferences();
      syncClockControls();
      startClock();

      headerClockEl.addEventListener('click', (evt) => {
        if (clockModalEl?.contains(evt.target)) {
          return;
        }
        evt.stopPropagation();
        if (clockModalEl?.classList.contains('visible')) {
          closeClockModal();
        } else {
          openClockModal();
        }
      });
      headerClockEl.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          openClockModal();
        }
      });

      document.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape' && clockModalEl?.classList.contains('visible')) {
          closeClockModal();
        }
      });

      clockAutoToggleEl?.addEventListener('change', () => {
        applyClockPreference({ autoTimezone: !!clockAutoToggleEl.checked });
      });

      clockRegionSelectEl?.addEventListener('change', (evt) => {
        const region = evt.target.value;
        if (!region) return;
        const nextZone = timeZoneGroups[region]?.[0] || '';
        populateZoneSelect(region, nextZone);
        applyClockPreference({ autoTimezone: false, timezone: nextZone });
      });

      clockZoneSelectEl?.addEventListener('change', (evt) => {
        const zone = evt.target.value;
        if (!zone) return;
        applyClockPreference({ autoTimezone: false, timezone: zone });
      });

      clockSecondsToggleEl?.addEventListener('change', () => {
        applyClockPreference({ showSeconds: !!clockSecondsToggleEl.checked });
      });

      clockDateToggleEl?.addEventListener('change', () => {
        applyClockPreference({ showDate: !!clockDateToggleEl.checked });
      });
    }

    function syncPerformanceToggle(enabled) {
      if (performanceModeToggleEl) {
        performanceModeToggleEl.checked = enabled;
      }
    }

    function updatePerformanceMode(enabled) {
      performanceState.performanceMode = !!enabled;
      syncPerformanceToggle(performanceState.performanceMode);
      applyPerformanceMode(performanceState.performanceMode);
    }

    async function loadPerformanceMode() {
      try {
        const res = await fetch('/api/performance_mode');
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updatePerformanceMode(!!data.enabled);
      } catch (err) {
        console.warn('Unable to load performance mode from backend', err);
      }
    }

    async function persistPerformanceMode(enabled) {
      try {
        const res = await fetch('/api/performance_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled }),
        });
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updatePerformanceMode(!!data.enabled);
      } catch (err) {
        console.error('Impossibile aggiornare la modalità prestazioni', err);
        if (performanceModeToggleEl) {
          performanceModeToggleEl.checked = performanceState.performanceMode;
        }
        alert('Impossibile aggiornare la modalità prestazioni');
      }
    }

    function initPerformanceMode() {
      updatePerformanceMode(initialPerformanceMode);

      if (performanceModeToggleEl) {
        performanceModeToggleEl.addEventListener('change', () => {
          persistPerformanceMode(performanceModeToggleEl.checked);
        });
      }

      loadPerformanceMode();
    }

    function syncDebugToggle(enabled) {
      if (debugModeToggleEl) {
        debugModeToggleEl.checked = enabled;
      }
    }

    function updateDebugMode(enabled) {
      performanceState.debugMode = !!enabled;
      document.body.dataset.debugMode = performanceState.debugMode ? '1' : '0';
      syncDebugToggle(performanceState.debugMode);
      document.dispatchEvent(
        new CustomEvent('debug-mode-changed', { detail: { enabled: performanceState.debugMode } })
      );
    }

    async function loadDebugMode() {
      try {
        const res = await fetch('/api/debug_mode');
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updateDebugMode(!!data.enabled);
      } catch (err) {
        console.warn('Unable to load debug mode from backend', err);
      }
    }

    async function persistDebugMode(enabled) {
      try {
        const res = await fetch('/api/debug_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ enabled }),
        });
        if (!res.ok) throw new Error('Request failed');
        const data = await res.json();
        updateDebugMode(!!data.enabled);
      } catch (err) {
        console.error('Impossibile aggiornare la modalità debug', err);
        if (debugModeToggleEl) {
          debugModeToggleEl.checked = performanceState.debugMode;
        }
        alert('Impossibile aggiornare la modalità debug');
      }
    }

    function initDebugMode() {
      updateDebugMode(initialDebugMode);

      if (debugModeToggleEl) {
        debugModeToggleEl.addEventListener('change', () => {
          persistDebugMode(debugModeToggleEl.checked);
        });
      }

      loadDebugMode();
    }

    function updateSafeModeState(enabled) {
      safeModeEnabled = !!enabled;
      document.body.dataset.safeMode = safeModeEnabled ? '1' : '0';
      if (safeModeToggleEl) {
        safeModeToggleEl.checked = safeModeEnabled;
      }
      window.d2haSafeMode = { enabled: safeModeEnabled };
      document.dispatchEvent(new CustomEvent('safe-mode-changed', { detail: { enabled: safeModeEnabled } }));
    }

    function registerPerformanceHandler(handler) {
      if (typeof handler !== 'function') return;
      window.d2haRuntime.performanceHandlers.push(handler);
      try {
        handler(!!performanceState.performanceMode);
      } catch (err) {
        console.error('Performance handler failed during registration', err);
      }
    }

    function applyPerformanceMode(enabled) {
      performanceState.performanceMode = !!enabled;
      window.d2haRuntime.performanceHandlers.forEach((handler) => {
        try {
          handler(performanceState.performanceMode);
        } catch (err) {
          console.error('Performance handler failed', err);
        }
      });
      document.dispatchEvent(
        new CustomEvent('performance-mode-changed', { detail: { enabled: performanceState.performanceMode } })
      );
    }

    function updateBackendStatus(durationMs) {
      const now = Date.now();
      const age = lastSuccessfulPing ? now - lastSuccessfulPing : Infinity;
      const el = backendStatusEl;
      if (!el) return;

      el.classList.remove('backend-status-ok', 'backend-status-degraded', 'backend-status-down');

      if (consecutiveErrors >= 2 || age > 30000) {
        el.classList.add('backend-status-down');
      } else if (age > 20000 || (durationMs || 0) > 800) {
        el.classList.add('backend-status-degraded');
      } else {
        el.classList.add('backend-status-ok');
      }
    }

    function updateBackendModalText() {
      if (!backendStatusLastUpdateEl) return;
      if (lastSuccessfulPing) {
        backendStatusLastUpdateEl.textContent = backendText.lastUpdate.replace('{timestamp}', formatClock(new Date(lastSuccessfulPing)));
      } else {
        backendStatusLastUpdateEl.textContent = backendText.noRecent;
      }
    }

    function closeBackendModal() {
      backendStatusModalEl?.classList.remove('visible');
    }

    async function pingBackend() {
      const start = performance.now();
      let durationMs = 0;
      backendStatusEl?.classList.add('backend-status-updating');
      try {
        const res = await fetch('/api/overview', { cache: 'no-store' });
        durationMs = performance.now() - start;
        if (!res.ok) throw new Error(`Status ${res.status}`);
        await res.json();
        lastSuccessfulPing = Date.now();
        consecutiveErrors = 0;
        updateBackendStatus(durationMs);
        updateBackendModalText();
      } catch (err) {
        console.error('Backend healthcheck failed', err);
        consecutiveErrors += 1;
        updateBackendStatus(durationMs);
      } finally {
        backendStatusEl?.classList.remove('backend-status-updating');
      }
    }

    function setupBackendStatusModal() {
      if (backendStatusEl) {
        backendStatusEl.addEventListener('click', () => {
          updateBackendModalText();
          backendStatusModalEl?.classList.add('visible');
        });
      }

      backendCloseBtn?.addEventListener('click', closeBackendModal);

      backendStatusModalEl?.addEventListener('click', (evt) => {
        if (evt.target === backendStatusModalEl) {
          closeBackendModal();
        }
      });

      backendRefreshBtn?.addEventListener('click', async () => {
        await pingBackend();
        try {
          if (typeof window.refreshOverview === 'function') {
            window.refreshOverview();
          }
        } catch (err) {
          console.error('Impossibile aggiornare immediatamente i dati', err);
        }
      });
    }

    function startBackendMonitor() {
      pingBackend();
      clearInterval(backendPingTimer);
      backendPingTimer = setInterval(pingBackend, 5000);
    }

    function loadDismissedNotifications() {
      try {
        dismissedNotifications = JSON.parse(localStorage.getItem('d2haDismissedNotifications') || '{}') || {};
      } catch (err) {
        dismissedNotifications = {};
      }
    }

    function ensureSafeConfirmModal() {
      if (safeConfirmState.modal) return;

      const backdrop = document.createElement('div');
      backdrop.className = 'safe-confirm-backdrop';
      backdrop.innerHTML = `
        <div class="safe-confirm-modal" role="dialog" aria-modal="true" aria-labelledby="safe-confirm-title">
          <h3 class="safe-confirm-title" id="safe-confirm-title">Conferma richiesta</h3>
          <p class="safe-confirm-message" data-safe-confirm-message></p>
          <div class="safe-confirm-actions">
            <button type="button" class="btn btn-secondary" data-safe-cancel>Annulla</button>
            <button type="button" class="btn" data-safe-confirm>Procedi</button>
          </div>
        </div>
      `;

      backdrop.addEventListener('click', (evt) => {
        if (evt.target === backdrop) {
          if (typeof safeConfirmState.resolver === 'function') {
            safeConfirmState.resolver(false);
          }
          closeSafeConfirmModal();
        }
      });

      const message = backdrop.querySelector('[data-safe-confirm-message]');
      const confirmBtn = backdrop.querySelector('[data-safe-confirm]');
      const cancelBtn = backdrop.querySelector('[data-safe-cancel]');

      confirmBtn?.addEventListener('click', () => {
        if (safeConfirmState.pendingForm) {
          safeConfirmState.pendingForm.submit();
        }
        if (typeof safeConfirmState.resolver === 'function') {
          safeConfirmState.resolver(true);
        }
        closeSafeConfirmModal();
      });

      cancelBtn?.addEventListener('click', () => {
        if (typeof safeConfirmState.resolver === 'function') {
          safeConfirmState.resolver(false);
        }
        closeSafeConfirmModal();
      });

      safeConfirmState.modal = backdrop;
      safeConfirmState.message = message;
      safeConfirmState.confirmBtn = confirmBtn;
      safeConfirmState.cancelBtn = cancelBtn;

      document.body.appendChild(backdrop);
    }

    function openSafeConfirmModal(message, form, resolver = null) {
      ensureSafeConfirmModal();
      safeConfirmState.pendingForm = form;
      safeConfirmState.resolver = resolver;
      if (safeConfirmState.message) {
        safeConfirmState.message.textContent = message;
      }
      safeConfirmState.modal?.classList.add('visible');
      safeConfirmState.confirmBtn?.focus({ preventScroll: true });
    }

    function closeSafeConfirmModal() {
      safeConfirmState.pendingForm = null;
      safeConfirmState.resolver = null;
      safeConfirmState.modal?.classList.remove('visible');
    }

    function requestConfirmation(message) {
      return new Promise((resolve) => {
        openSafeConfirmModal(message, null, resolve);
      });
    }

    initCompactMode();
    initClockSettings();
    initMobileDrawer();

  function saveDismissedNotifications() {
    localStorage.setItem('d2haDismissedNotifications', JSON.stringify(dismissedNotifications));
  }

  function shouldIgnoreNotification(item) {
    const entry = dismissedNotifications[item.id];
    return entry && entry.count >= item.count;
  }

  function updateBadge(count) {
    if (!notifBadgeEl) return;
    if (count > 0) {
      notifBadgeEl.textContent = count;
      notifBadgeEl.style.visibility = 'visible';
    } else {
      notifBadgeEl.textContent = '0';
      notifBadgeEl.style.visibility = 'hidden';
    }
  }

  function dismissNotification(item) {
    dismissedNotifications[item.id] = { count: item.count, ts: Date.now() };
    saveDismissedNotifications();
    renderNotificationList(currentNotifications);
  }

  function attachSwipeToDismiss(element, item) {
    let touchStartX = null;
    element.addEventListener('touchstart', (ev) => {
      touchStartX = ev.changedTouches[0]?.clientX || 0;
    });
    element.addEventListener('touchend', (ev) => {
      if (touchStartX === null) return;
      const delta = (ev.changedTouches[0]?.clientX || 0) - touchStartX;
      if (Math.abs(delta) > 45) {
        dismissNotification(item);
      }
      touchStartX = null;
    });
  }

  function buildNotificationItems(data) {
    const items = [];
    const unused = data?.unused_images || {};
    if (unused.count > 0) {
      items.push({
        id: 'unused-images',
        count: unused.count,
        title: 'Immagini non utilizzate',
        description: `${unused.count} immagini · Spazio liberabile: ${unused.reclaimable_h || '-'}`,
      });
    }

    if ((data?.updates_pending || 0) > 0) {
      const count = data.updates_pending;
      items.push({
        id: 'updates-pending',
        count,
        title: 'Container da aggiornare',
        description: `${count} container non ancora aggiornati`,
      });
    }

    if ((data?.critical_events || 0) > 0) {
      const count = data.critical_events;
      items.push({
        id: 'critical-events',
        count,
        title: 'Eventi critici',
        description: `${count} eventi critici o fatali registrati (ultime 24h)`,
      });
    }

    return items;
  }

  function renderNotificationList(data) {
    currentNotifications = data || {};
    const items = buildNotificationItems(currentNotifications);
    const visible = items.filter((item) => !shouldIgnoreNotification(item));

    if (!notifListEl) return;
    notifListEl.innerHTML = '';

    if (visible.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'notif-empty';
      empty.textContent = 'Nessuna notifica al momento';
      notifListEl.appendChild(empty);
      updateBadge(0);
      return;
    }

    visible.forEach((item) => {
      const row = document.createElement('div');
      row.className = 'notif-item';
      row.dataset.id = item.id;

      const content = document.createElement('div');
      content.className = 'notif-content';

      const title = document.createElement('div');
      title.className = 'notif-title';
      title.textContent = item.title;

      const desc = document.createElement('div');
      desc.className = 'notif-desc';
      desc.textContent = item.description;

      content.appendChild(title);
      content.appendChild(desc);

      const dismissBtn = document.createElement('button');
      dismissBtn.className = 'notif-dismiss';
      dismissBtn.type = 'button';
      dismissBtn.setAttribute('aria-label', 'Ignora notifica');
      dismissBtn.textContent = '×';
      dismissBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        dismissNotification(item);
      });

      row.appendChild(content);
      row.appendChild(dismissBtn);
      attachSwipeToDismiss(row, item);
      notifListEl.appendChild(row);
    });

    updateBadge(visible.length);
  }

  function toggleNotifications(open = null) {
    if (!notifPanelEl || !notifToggleEl) return;
    const shouldOpen = open === null ? !notifPanelEl.classList.contains('open') : open;
    notifPanelEl.classList.toggle('open', shouldOpen);
    notifToggleEl.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    if (shouldOpen && settingsPanelEl) {
      settingsPanelEl.classList.remove('open');
      settingsToggleEl?.setAttribute('aria-expanded', 'false');
    }
  }

  function toggleSettings(open = null) {
    if (!settingsPanelEl || !settingsToggleEl) return;
    const shouldOpen = open === null ? !settingsPanelEl.classList.contains('open') : open;
    settingsPanelEl.classList.toggle('open', shouldOpen);
    settingsToggleEl.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
    if (shouldOpen && notifPanelEl) {
      notifPanelEl.classList.remove('open');
      notifToggleEl?.setAttribute('aria-expanded', 'false');
    }
  }

  function setupNotificationToggle() {
    if (!notifToggleEl) return;
    notifToggleEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleNotifications();
    });

    document.addEventListener('click', (ev) => {
      if (!notifPanelEl || !notifToggleEl) return;
      const target = ev.target;
      if (
        notifPanelEl.contains(target) ||
        notifToggleEl.contains(target) ||
        settingsPanelEl?.contains(target) ||
        settingsToggleEl?.contains(target)
      ) {
        return;
      }
      toggleNotifications(false);
      toggleSettings(false);
    });
  }

  function setupSettingsToggle() {
    if (!settingsToggleEl) return;
    settingsToggleEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleSettings();
    });
  }

  async function refreshNotifications() {
    try {
      const res = await fetch('/api/notifications');
      if (!res.ok) return;
      const data = await res.json();
      renderNotificationList(data);
    } catch (err) {
      console.error('Failed to refresh notifications', err);
    }
  }

  async function persistSafeMode(enabled) {
    try {
      const res = await fetch('/api/safe_mode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled }),
      });
      if (!res.ok) throw new Error('Request failed');
      const data = await res.json();
      updateSafeModeState(!!data.enabled);
    } catch (err) {
      console.error('Impossibile aggiornare la modalità sicura', err);
      if (safeModeToggleEl) {
        safeModeToggleEl.checked = safeModeEnabled;
      }
      alert('Impossibile aggiornare la modalità sicura');
    }
  }

    function setupSafeModeToggle() {
      if (!safeModeToggleEl) return;
      safeModeToggleEl.addEventListener('change', () => {
        persistSafeMode(safeModeToggleEl.checked);
      });
    }

    function setupSafeConfirmations() {
      document.addEventListener(
        'submit',
        (ev) => {
          const form = ev.target;
          if (!(form instanceof HTMLFormElement)) return;
          const message = form.dataset.safeConfirm;
          const handledElsewhere = form.dataset.safeModal === 'external';
          if (!message || !safeModeEnabled || handledElsewhere) return;

          ev.preventDefault();
          openSafeConfirmModal(message, form);
        },
        true,
      );
    }

  window.registerPerformanceHandler = registerPerformanceHandler;
  window.applyPerformanceMode = applyPerformanceMode;
  window.d2haConfirm = requestConfirmation;
  initPerformanceMode();
  initDebugMode();
  loadDismissedNotifications();
  updateSafeModeState(safeModeEnabled);
  renderNotificationList(currentNotifications);
  setupNotificationToggle();
  setupSettingsToggle();
  setupSafeModeToggle();
  setupSafeConfirmations();
  setupBackendStatusModal();
  startBackendMonitor();
  refreshNotifications();
  setInterval(refreshNotifications, 60000);
})();
</script>
